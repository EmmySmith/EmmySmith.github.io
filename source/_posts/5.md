---
title: 浅谈Pycharm之Unittest的接口自动化测试
date: 2019-06-02 20:04:13
tags: 接口
categories: 技术
summary_img: /image/5.gif
---


##### 工作中一直使用Python+Unittest做接口自动化测试,今天有时间总结一下

## 前置条件
```
1. 安装[Python](https://www.python.org/)
2. 安装[Pycharm](http://www.jetbrains.com/pycharm/?fromMenu)
3. 配置环境变量
```

### 1. 接口自动化框架
* 涉及到接口自动化的框架，主要包括公共类，case类，测试数据，测试报告等4大类
![VGWzqK.png](https://s2.ax1x.com/2019/06/02/VGWzqK.png)

### 2. 公共类
* 公共类中主要是用到的公共数据（环境，数据，headers）,不同的端分为不同的`.py`文件。例如后台+前台
![VGfbef.png](https://s2.ax1x.com/2019/06/02/VGfbef.png)
![VGhEY4.png](https://s2.ax1x.com/2019/06/02/VGhEY4.png)

### 3.case类
* case类是最主要的类，用于不同的分类，这是接口自动化的核心用的最多的类。按照不同的业务端可以分为不同的文件夹下创建不同的`.py`文件
![VYlGtJ.png](https://s2.ax1x.com/2019/06/03/VYlGtJ.png)

### 4.测试数据
* 测试数据主要是在case类中可能用到的数据，可使用ddt执行数据驱动测试方法上传的数据或者需要用到的数据(例如:.json文件)
![VY1QgI.png](https://s2.ax1x.com/2019/06/03/VY1QgI.png)

### 5.测试报告
* 测试报告用于生成测试报告，可通过邮件进行发送或定时发送测试报告，测试报告可通过默认的`HTMLTestRunner.py`的模板生成。测试报告是以`.html`文件显示
![VUeZBF.png](https://s2.ax1x.com/2019/06/05/VUeZBF.png)
* 查看一下基础的`.html`文件，生成的测试报告如果自己会前端技术的童鞋可以按照自己的想法修改不同的样式
![VUeUNd.png](https://s2.ax1x.com/2019/06/05/VUeUNd.png)

### 6.详细解析接口自动化逻辑
#### 6.1 headers
* 获取前使用headers是接口自动化最关键的第一步，只有登录后才能执行`case类`。把登录中的`headers`放在公共类中方便每个case调用
![VUexv6.png](https://s2.ax1x.com/2019/06/05/VUexv6.png)

#### 6.2登录接口
* 登录接口最好放在单独的文件夹中，不同的业务有不同登录接口，一般的登录接口只有一个，有两个登录接口执行case有优先顺序，不然无法登录，登录成功后就会有`token`，把获取的`token`同步到公共类的`headers`中
![VUmNrT.png](https://s2.ax1x.com/2019/06/05/VUmNrT.png)

#### 6.3执行业务case
* 每个业务执行接口运行前都要有`headers`才能执行，在执行前从`headers`中同步`token`到执行业务case中。同样的不同的业务接口都会有先后顺序
![VUmDi9.png](https://s2.ax1x.com/2019/06/05/VUmDi9.png)

#### 6.4运行单个业务case
* 针对简单的单一接口我们还是可以执行单个接口，优先顺序其实没那么重要，但针对有复杂业务来说接口自动化不同接口之间的耦合性会很强，所以用`Unittest`的框架执行如下：
![VUnalt.png](https://s2.ax1x.com/2019/06/05/VUnalt.png)

#### 6.5两个接口之间入参和出参的调用
* 刚刚也说到不同的上下业务接口间调用如何实现呢，下一个接口的入参需要上一个接口的返回值来传参，首先上一个接口正常编写只是返回的`response`里下一个接口需要用到的`入参值`需要由`str`格式通过`json.loads`转化成`dict`格式获取，然后通过`公共类`中的入参值传值到下一个接口，下一个接口中入参直接从`公共类`中获取即可
![VU1R1J.png](https://s2.ax1x.com/2019/06/05/VU1R1J.png)

#### 6.6多个文件之间运行case
* 创建不同的文件可以方便的区分不同的业务，同时执行有相互依赖的文件执行会有先后顺序，`run`时最好要确定如何运行并确定执行的先后顺序
![VUGXjJ.png](https://s2.ax1x.com/2019/06/05/VUGXjJ.png)

#### 6.7 run_case.py
* 单独写一个执行所有`case`文件，并发送测试报告,具体的解释已经在以下代码详解中
```
def new_file(test_dir):
    #列举test_dir目录下的所有文件，结果以列表形式返回。
    lists=os.listdir(test_dir)
    #sort按key的关键字进行排序，lambda的入参fn为lists列表的元素，获取文件的最后修改时间
    #最后对lists元素，按文件修改时间大小从小到大排序。
    lists.sort(key=lambda fn:os.path.getmtime(test_dir+fn))
    #获取最新文件的绝对路径
    file_path=os.path.join(test_dir,lists[-1])
    return file_path

if __name__=="__main__":
    print ('===== Start  ======')
    # 1.执行测试用例，生成最新的测试用例
    # 指定测试用例为当前文件夹下的test_case目录

    test_dir = './'
    # 指定测试报告的路径
    test_report_dir = './'

    # 包装测试用例
    suite = unittest.TestSuite()
    suite = unittest.defaultTestLoader.discover(test_dir, pattern='a_*.py')

    #生成与执行时间相同的测试报告
    now = time.strftime('%Y-%m-%d_%H_%M_%S_')
    filename = test_report_dir +'test_report'+ now + 'result.html'
    fp = open(filename, 'wb')

    runner = HTMLTestRunner.HTMLTestRunner(stream=fp, title=u'测试报告', description=u'用例执行情况：')
    runner.run(suite)
    fp.close()

    # 2.取最新测试报告
    new_report = new_file(test_report_dir)
    htmlf = open(new_report, 'r', encoding="utf-8")
    htmlcont = htmlf.read()
    # print(htmlcont)

    html = BeautifulSoup(htmlcont, 'html.parser')
    aaa = html.body.find('tr', id='total_row').find_all('td')[3].text

    # 3.发送邮件，发送最新测试报告html
    if aaa != 0:
        send_email(new_report)

    else:
        print("test pass!")
```

### 7.其他细节技术
#### 7.1 时间戳
* 在一些业务中时间戳肯定会经常用到，因数据库中存储时间会以时间戳来存储，就会有开始时间、结束时间、显示时间等各种情况显示
![VUJZDA.png](https://s2.ax1x.com/2019/06/05/VUJZDA.png)

#### 7.2 多个文件之间引入
* 有时候不同文件之间无法引用，按照本人的理解应该没有导入成功，包含路径(绝对路径)，安装包，需要正常的引入或者导入成功调用就是很简单的事了
![VaVjNd.png](https://s2.ax1x.com/2019/06/06/VaVjNd.png)










  